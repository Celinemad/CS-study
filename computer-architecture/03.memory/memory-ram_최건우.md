# ᴍᴇᴍᴏʀʏ & ᴄᴀᴄʜᴇ ᴍᴇᴍᴏʀʏ

# RAM의 특징과 종류

1. 주기억장치 중 RAM에 대해 자세히 알아보도록 하겠음.
2. 우선 RAM의 특징은, 전원을 끄면 날아가는 휘발성이라는 것임.
3. 보조기억장치가 비휘발성인 것과 대비됨.
4. RAM의 용량이 크면 보조기억장치에서 불러올 일이 적어지기 때문에 성능이 높아질 수밖에 없음.
5. 이제 DRAM, SRAM에 대해 알아보겠음.
6. `DRAM`은 Dynamic ram의 준말로, 저장된 데이터가 동적인(사라지는) RAM임.
7. DRAM은 축전기 `Capacitor` 기반의 저장장치라서 전하가 빠지면 데이터가 점점 사라짐.
8. 그렇기 때문에 유지하기 위해서는 일정 주기로 `데이터를 재활성화` 해줘야 함.
9. 대신 capacitor와 트랜지스터 1개씩만으로 단순하게 구성되기 때문에, 집적도가 높아 대용량 설계가 유리함. 
10. `SRAM`은 Static RAM의 준말로, 데이터가 시간이 지나도 사라지지 않음.
11. SRAM은 플립플롭 `flip-flop` 회로 기반의 저장장치라서 데이터가 계속 유지됨.
12. 다만, 전원이 없어도 유지된다는 뜻이 아님. 전원이 공급되지 않으면 내용이 날아감.
13. flip-flop 회로의 복잡도 때문에, 집적도가 낮고 가격이 높을 수 밖에 없음.
14. 그래서 cache 등에서 활용됨.
15. `SDRAM` 은 SRAM과 DRAM이 아니고, `Synchronous DRAM` 임. 동기화된 DRAM이라는 뜻.
16. 무엇과 동기화된건고 하니, 클럭 타이밍에 맞춰 CPU와 정보를 주고받을 수 있음.
17. `DDR SDRAM`은 `Double Data Rate SDRAM` 임. 한 클럭에 데이터를 두번씩 주고받음.
18. `DDR2 SDRAM` 은 `DDR SDRAM`의 2배, DDR3는 DDR2의 2배… 이렇게 늘어남.

# 메모리의 주소공간

19. 우리가 코드에서 찍어보는 포인터 값은 물리주소가 아님.
2. 프로그램마다 논리주소가 따로 구분되는 것.
3. Instruction은 프로그램에서 받은 논리주소를 해석해서 물리주소에 접근함.
4. 이때 프로그램마다 배정받은 물리 주소를, `Memory Management Unit(MMU)`가 관리함. 
5. 가령, 15000 번지가 저장되어있다면 논리 100번지를 더해 15100번지로 접근하는 것.
6. 이때 MMU에 물리주소가 저장되어있는 곳을 `Base register`라고 함.
7. 다른 생각을 해볼 수 있음. 과연 너무 큰 논리주소라서 다른 영역의 메모리에 침범한다면?
8. 이때 `limit register`가 필요함.
9. 가령 프로그램의 할당 메모리 크기가 500인데 600으로 접근한다면, limit register에 저장된 500과 비교해서 문제가 있음을 확인함.
10. 이 다음에는 인터럽트(트랩)이 발생하는 것임.

# 캐시 메모리

![Untitled 1](https://github.com/Ssafy-Developer-Study/CS-study/assets/39848764/db7d1b5b-d334-478a-8bcd-a39f290d16c5)

29. 저장장치 계층구조 `Memory hierachy` 에 대해 알아야 함. 
2. 위로 갈수록 용량이 작고, 가격도 비싸고, 접근 속도도 빨라짐.
3. 일반적으로 CPU와의 거리에도 연관이 있음. 멀수록 느려짐.
4. 캐시 메모리는 Dynamic memory와 register 사이의 중간 계층을 만들어 성능을 높이는 방식임.
5. Cache는 SRAM 기반으로 만듦. 더 빠르기 때문.
6. 코어와 가장 가까운 메모리가 L1, 그 다음이 L2, 그 다음이 L3임.
7. 캐시 메모리는 보통 L1, L2가 코어 안에, L3가 코어 밖에 있음.
8. 보통 L3는 여러 코어가 공유하는 형태임.

![Untitled 2](https://github.com/Ssafy-Developer-Study/CS-study/assets/39848764/3ef66147-2c33-401e-a9b9-d334846fcd32)

37. 그리고 instruction을 저장하는 `L1I`와 data를 저장하는 `L1D` 가 분리된 아키텍쳐도 있음.
10. 이제 참조 지역성 원리에 대해 알아봐야 함.
3. 캐시 히트라는 개념인데, 캐시가 실제로 내가 필요한 데이터를 들고 있는 상황임.
4. 반대로 캐시에 없어서 메모리로 접근해야 한다면 캐시 미스라고 함.
5. 캐시 적중률은 `캐시히트 + 캐시미스` 대비 `캐시히트` 횟수의 비율임.
6. 캐시는 참조지역성의 원리를 기반으로 데이터를 결정함.
7. 첫번째는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향, 두번째는 접근한 메모리공간 근처를 접근하려는 경향임.
8. 이를 이용하면 array에서 정렬할 때 효율적인 알고리즘에 대한 practical한 속성이 나타나기도 함.
