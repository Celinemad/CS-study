# 컴퓨터 구조


## 1 ) 컴퓨터 구조 시작하기

1. 구조를 알아야 하는 이유
    1. 실력 있는 개발자가 되려면 반드시 알아야 할 기본 지식
    2. 문제 해결
        1. 컴퓨터 구조를 이해하고 있다면 문제 상황을 빠르게 진단할 수 있다.
        2. 문제 해결의 실마리를 다양하게 찾을 수 있다.
    3. 성능, 용량, 비용
        1. 최적의 컴퓨터 환경을 위해 위의 3가지를 고려해야 한다.
2. 컴퓨터 구조의 큰 그림
    1. 컴퓨터가 이해하는 정보
    2. 컴퓨터의 4가지 핵심 부품
        1. 메모리
            - 명령어와 데이터를 저장하는 부품이다.
            - 프로그램이 실행되려면 반드시 메모리에 저장되어 있어야 한다.
            - 메모리는 현재 실행되는 프로그램의 명령어와 데이터를 저장한다.
            - 메모리에 저장된 값의 위치를 주소로 알 수 있다.
        2. CPU
            - 컴퓨터의 두뇌
            - 메모리에 저장된 명령어를 읽어들이고, 읽어드린 명령어를 해석하고, 실행하는 부품이다.
            - CPU 구성 요소
                - ALU(산술 논리 연산장치)
                    - 계산기 역할
                - 레지스터
                    - CPU 내부의 작은 저장 장치, 여러 개가 존재하고 각각 이름을 갖는다.
                - 제어장치
                    - 제어신호라는 전기 신호를 내보내고, 명령어를 해석하는 장치
        3. 보조 기억 장치
            - 전원이 꺼져도 저장되는 메모리, 읽지 않아야하는 데이터 저장한다.
        4. 메인보드와 시스템 버스
            - 메인보드 내부에 ‘버스’라는 통로로 연결된 부품들 서로 정보를 주고 받는다.
            - 여러 버스 중 컴퓨터의 4가지 핵심 부품을 연결하는 가장 중요한 버스는 ‘시스템 버스’이다.
            - 종류
                - 주소 버스 : 주소를 주고받는 통로
                - 데이터 버스 : 명령어와 데이터를 주고받는 통로
                - 제어 버스 : 제어 신호를 주고받는 통로
    3. 어떤 값을 저장할 때 CPU 과정
        1. 데이터 버스를 통해 메모리에 저장할 값을
        2. 주소 버스를 통해 저장할 주소를
        3. 제어 버스를 통해 ‘메모리 쓰기’ 제어신호를 내보낸다.
    4. 주기억 장치와 보조 기억 장치의 차이
        1. 주기억 장치
            - 휘발성
            - 빠름
            - 용량이 작음
        2. 보조 기억 장치
            - 비휘발성
            - 느림
            - 용량이 큼
            

## 2 ) 데이터

1. 0과 1로 숫자를 표현하는 방법
    1. 정보 단위
        1. 컴퓨터는 기본적으로 bit라는 정보 단위를 사용한다.
            - N bit 라면 2^N가지를 표현할 수 있다.
        2. 단위
            - 1바이트(1byte) : 8비트(8bit)
            - 1키비바이트(1kiB) : 1024바이트(1024byte)
            - 1미비바이트(1MiB) : 1024키비바이트(1000kiB)
            - 1기비바이트(1GiB) : 1024미비바이트(1000MiB)
            - 1테비바이트(1TiB) : 1024미비바이트(1000GiB)
    2. 이진법
        1. 1을 넘어가는 시점에 자리 올림을 하여 0과 1로만 숫자를 표현하는 방법이다.
        2. 1의 보수
            - 비트들을 반전시켜서 음수를 표현하는 방법
        3. 2의 보수
            - 1의 보수법에 1을 더하는 방법
    3. 십육진법
        1. 15를 넘어갈 때 자리 올림
        2. 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, A, B, C, D, F
2. 0과 1로 문자를 표현하는 방법
    1. 문자 집합과 인코딩
        1. 문자 집합
            - 컴퓨터가 이해할 수 있는 문자의 모음
            - 먄약 문자 집합에 존재하지 않는다면 컴퓨터는 이애할 수 없다.
        2. 인코딩(encoding)
            - 문자집합에 속한 문자를 0과 1로 이루어진 문자코드를 변환하는 과정
        3. 디코딩(decoding)
            - 0과 1로 표현된 문자코드를 문자로 변환하는 과정
    2. 아스키 코드
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ccd9570b-85c2-4c37-a7ea-3521eb1cd311/bf3c8aa9-96be-407b-91d5-b9326a0e3ff6/Untitled.png)
        
        1. 알파벳, 아라비아 숫자, 일부 특수 문자 및 제어 문자를 표현할 수 있다.
        2. 7bit로 표현할 수 있다.
            - 원래 8bit로 표현되지만, 1bit는 오류 검출을 위한 패트리 bit로 사용된다.
            - 7bit = 2^7 = 128
        3. 단점
            - 한글을 포함한 다양한 언어, 특수 문자 등을 표현할 수 없다.
            - 이를 위해 언어별 인코딩 방식이 등장했다.
                - 완성형 인코딩 방식
                    - 단어에 고유의 코드를 부여하는 방식
                - 조합형 인코딩 방식
                    - 초성, 중성, 종성 각각에 고유 코드를 부여하여 조합하는 방식
    3. EUC-KR
        1. 완성형 인코딩 방식
        2. 글자 하나에 2byte 크기의 코드를 부여하여 표현한다.
        3. 16자리의 이진수, 4자리의 십유진수로 표현할 수 있다.
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ccd9570b-85c2-4c37-a7ea-3521eb1cd311/167807aa-485d-4d2a-9594-42550c532d67/Untitled.png)
            
        4. 단점
            - 쀏, 뙠과 같은 한글을 표현할 수 없다.
            - 국가마다 언어별로 인코딩을 하게 되면 다국어를 지원하는 프로그램을 개발할 때, 언어별 인코딩 방식을 모두 이해하고 포함시켜야 한다.
    4. 유니코드와 UTF-8
        1. 모든 언어, 특수문자까지 포함할 수 있는 문자 집합을 사용하자는 요구에서 생겨난게 유니코드 문자 집합과 UTF-8인코딩 방식이다.
        2. 유니코드
            - 한글, 영어 뿐만 아니라 특수 문자, 이모티콘까지 통일된 문자 집합
            - 이 유니코드의 문자 집합을 인코딩 방식이 UTF-8이다.
            - 유니코드 문자 집합의 인코딩 방식은 UTF-8 이외에도 UTF-16, UTF-32 등이 존재한다.

## 3 ) 명령어

1. 소스 코드와 명령어
    1. 고급 언어와 저급 언어
        1. 컴퓨터는 저급 언어(기계어)로 변환해야 이해할 수 있다.
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ccd9570b-85c2-4c37-a7ea-3521eb1cd311/ef601bbb-f247-4115-aabc-dd60de5884aa/Untitled.png)
            
            - 기계어 : 2진수 또는 16진수로 표현된 저급언어
            - 어셈블리어 : 기계어를 사람들이 읽기 편한 형태로 변환한 저급언어
        2. 개발자를 위한 언어를 고급언어(C, C++, Java, Python 등)라고 한다.
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ccd9570b-85c2-4c37-a7ea-3521eb1cd311/f93638fa-f488-4a6c-b32a-54bf999ad097/Untitled.png)
            
            - 컴파일 언어 : 컴파일 언어는 소스코드 전체를 컴파일러가 기계어로 번역하고 실행하는 구조
            - 인터프리터 언어 : 인터프리터가 소스코드 한 줄씩 번역하여 실행하는 구조
            - 컴파일 언어 vs 인터프리터 언어
                - 컴파일 언어는 실행되기 위해 전체 소스코드를 컴파일러가 해석하는 과정을 통해 오류를 발견하고 에러를 반환한다.
                - 인터프리터 언어는 오류 직전까지 실행이 가능하다.
    2. 컴파일 언어와 인터프리터 언어
        1. 컴파일 언어
            - 고급 언어로 작성된 소스 코드를 저급 언어로 번역하는 프로그램
            - 컴파일러 언어는 컴파일 단계와 실행 단계가 각각 분리되어 있으며, 단 한번만 수행한다.
            - 컴파일 단계
                - 컴파일러 언어는 컴파일러를 통해 컴파일 타임에 전체 소스 코드를 한 번에 기계어로 변환 후 실행 파일을 만든다.
            - 실행 단계
                - 생성된 실행 파일을 실행시켜 컴파일 과정을 거치지 않고 실행만 하면 되므로 코드 실행 속도가 빠르다.
            - 프로젝트 규모가 클 경우 컴파일 시간이 오래 걸릴 수 있다는 단점이 있다.
        2. 인터프리터 언어
            - 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램
            - 인터프리터 언어는 컴파일하지 않고 소스 코드를 한 줄씩 읽어들여 실행한다.
            - 컴파일하는 과정이 없기 때문에 컴파일하는 시간은 소요되지 않으나, 인터프리터 언어는 실행파일을 별도로 생성하지 않기 때문에 실행 시 마다 인터프리터 과정이 반복 수행되어 실행 속도가 느리다.
        3. 컴파일러 언어 vs 인터프리터 언어
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ccd9570b-85c2-4c37-a7ea-3521eb1cd311/f59f5223-0f10-490b-824d-58ee7a469f1e/Untitled.png)
            
    3. 목적 파일 vs 실행 파일
2. 명령어의 구조
    1. 연산 코드와 오퍼랜드
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ccd9570b-85c2-4c37-a7ea-3521eb1cd311/67141b71-6fa3-4493-8118-bd8bec25a537/Untitled.png)
        
        1. 연산 코드(Operation code)
            - 데이터 전송
                - 데이터를 옮기고(MOVE), 메모리에 저장하고(STORE), 메모리에서 CPU로 데이터를 가져오고(FETCH), 데이터를 스택에 저장하고(PUSH), 스택에서 데이터를 가져오는 (POP) 명령어
            - 산술 / 논리 연산
                - 4칙 연산, AND / OR / NOT 논리 등
            - 제어 흐름 변경
                - 특정 주소로 실행(JUMP), 특정 조건 시 특정 주소 실행(CONDITIONAL JUMP), 실행을 멈추기(HALT), 되돌아올 주소를 저장하고 특정 주소 실행(CALL), CALL을 호출할 때 저장했던 주소로 돌아오기(RETURN)
            - 입출력 제어
                - 특정 입출력 장치로부터 데이터 읽기(READ), 쓰기(WRITE), 입출력 장치 시작(START IO), 상태확인(TEST IO)
        2. 오퍼랜드(Operand)
            - 연산에 사용될 데이터 또는 데이터가 저장된 위치를 명시한다.
            - 저장된 위치를 명시하는 경우가 훨씬 많기 때문에 오퍼랜드의 필드를 주소필드라고도 표현한다.
                - 표현 가능한 데이터가 한정적이기 때문에 주소를 명시하는게 효율적이다.
    2. 주소 지정 방식
        1. 즉시 주소 지정방식
            - 오퍼랜드 필드에 데이터를 직접 명시하는 방식
            - 장점
                - 데이터를 찾는 과정이 없어 빠르다.
            - 단점
                - 데이터를 표현할 수 있는 크기가 제한된다.
        2. 직접 주소 지정방식
            - 오퍼랜드 필드에 유효주소를 직접적으로 명시하는 방식
            - 간접 주소 지정방식 보다는 빠르지만 메모리의 용량이 큰 경우 오퍼랜드의 길이가 길어진다.
        3. 간접 주소 지정방식
            - 오퍼랜드 필드에 유효주소를 가르키는 유효주소를 명시하는 방식
            - 장점
                - 기억장치의 용량만큼 주소를 표현할 수 있다.
            - 단점
                - 2번 접근해야 한다.
        4. 레지스터 주소 지정방식
            - 오퍼랜드 필드에 데이터가 저장된 레지스터의 번호를 명시하는 방식
            - 기본적으로 CPU는 메모리 접근보다 레지스터에 접근하는 것이 빠르다.
            - 하지만 데이터가 저장될 수 있는 공간이 CPU 내부 레지스터들로 제한된다.
        5. 레지스터 간접 주소 지정방식
            - 오퍼랜드 필드에 유효주소를 가르키는 레지스터 번호를 명시하는 방식
            - 주소를 지정할 수 있는 기억장치의 영역이 확장되는 장점이 있다.
