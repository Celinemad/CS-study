# 🅒🅟🅤의 작동 원리

# ALU와 제어장치

1. CPU에는 ALU, 레지스터, 제어장치가 들어감.

### ALU

2. ALU는 CPU에 들어가는 계산기임.

3. ALU는 레지스터로부터 (피연산자, operand)값을 받고, 제어장치에서 제어신호를 받음.
4. 그리고 플래그 레지스터에 플래그를, 레지스터에 결괏값을 뱉음.
5. 플래그는 연산 결과의 추가적인 정보임.
6. 부호 플래그, 제로 플래그, 캐리 플래그, 오버플로우 플래그, 인터럽트 플래그, 슈퍼바이저 플래그 등이 있음.
7. 플래그는 플래그 레지스터에 저장됨.
8. ALU엔 adder 뺄셈용 보수기, 시프터, 오버플로우 검출기 등이 들어감.

### 제어 장치

9. 제어장치는 말 그대로 제어신호를 보내는 장치.
10. 제어신호는 클럭신호 `clock`, 해석해야 할 명령어 `instruction` , 플래그 레지스터 속 플래그 값 `flag`, 시스템 버스(제어 버스)로 전달된 제어 신호를 받아들임.

![image](https://github.com/Ssafy-Developer-Study/CS-study/assets/39848764/533dd2d4-0cc8-4e36-b250-1cb2a39acd64)

11. 클럭은 컴퓨터의 동작이 작동하는 시간의 단위. `ex) Float div = 3 clock.`
12. 해석해야 할 명령어는 명령어 레지스터로부터 불러옴.
13. 플래그는 플레그 레지스터로부터 값을 따옴

# 레지스터

14. 메모리는 멀리있어서 느림.
15. CPU는 그 메모리 대신 접근할 수 있는 값이고, 프로그램 속 명령어와 데이터는 실행 전후에 반드시 레지스터에 저장됨.
16. 레지스터의 종류에는
    1. 프로그램 카운터
    2. 명령어 레지스터
    3. 메모리 주소 레지스터
    4. 메모리 버퍼 레지스터
    5. 플래그 레지스터
    6. 범용 레지스터
    7. 스택 포인터
    8. 베이스 레지스터
    
    가 있음.
![Untitled 2](https://github.com/Ssafy-Developer-Study/CS-study/assets/39848764/8e5d8935-acba-4a33-9bae-ccff756d787b)


17. `PC: Program Counter(IP: Instruction Pointer)` 는 **“메모리에서 가져올 명령어의 주소”**를 저장함. 한번 읽을 때 마다 다음 명령의 위치로 증가시키거나 `JUMP, RET`  등의 명령을 받으면 변경됨
18. 명령어 레지스터 `IR: Instruction Register` 는 방금 읽어들인 명령어를 저장함
19. 메모리 주소 레지스터 `MAR: Mem Addr Register` 는 메모리의 주소를 저장함. CPU가 읽고자 하는 주소값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 됨.
20. 메모리 버퍼 레지스터 `MBR: Mem Buf Register(MDR: Mem Data Register)` 는 메모리와 주고 받을 값을 저장하는 레지스터. `CPU→주소 버스`로 내보낼 값이 `MAR`을 거친다면, `데이터버스`로 주고받을 값은 MBR을 거침
21. 범용 레지스터 `General Purpose Register` 는 다양하고 일반적인 상황에 자유롭게 사용.
22. 플래그 레지스터 `Flag Register` 는 ALU같은 애들이 부가적인 정보를 저장해줌

## 주소지정방식(1) 스택 주소 지정 방식

23. 레지스터에 대해 더 공부해야만 이해할 수 있는 방식인 `스택주소 지정방식()`이 있음.
24. 스택 주소 지정 방식은 스택과 스택 포인터를 이용함.
25. `스택 포인터`는 스택의 값이 저장된 꼭대기 층을 의미함.
26. 메모리 안에 스택처럼 사용하는 영역이 있고, 다른 주소공간과 다르게 스택처럼 사용하기로 암묵적으로 약속된 영역이 있는 것.

## 주소지정방식(2) 변위 주소 지정 방식

27. 오퍼랜드 필드에는 메모리의 주소가 담길 때도 있음.
28. `변위주소 지정방식(displaceemnt addressing mode)` 은 레지스터에 저장된 값 + operand 값을 더해서 유효 주소를 얻어내는 방식.
29. operand에 index가, 레지스터에 배열의 첫 원소 주소가 있는 상황을 상상하면 될듯.
![Untitled 3](https://github.com/Ssafy-Developer-Study/CS-study/assets/39848764/aa5f3ea1-06e2-497d-8d88-811c0e10646f)



### (2-1) 상대 주소 지정 방식

30. 상대주소 지정방식은 오퍼랜드와 `PC` 값을 더하는 방식임.

### (2-2) 베이스 레지스터 주소 지정 방식

31. 베이스 레지스터 주소 지정 방식은 오퍼랜드와 `base register` 값을 더하는 방식임.
32. 베이스 레지스터는 추후에 나올 개념임.

# 명령어 사이클과 인터럽트

33. 명령어를 처리하는 정형화된 흐름을 명령어 사이클이라고 함
34. 프로그램 속 명령어들은 일정한 주기가 반복되며 실행되는데, 이 주기를 `명령어 사이클 (instruction cycle)`이라고 함.
35. 일반적으로 `fetch cycle` , `execution cycle` 이 반복되며 수많은 명령어들이 돌아감
36. 메모리 접근을 한번씩 더 해야 하는 경우, 추가적으로 간접 사이클 `indirect cycle` 이 돌수도 있음.
37. 그리고 이제는 **인터럽트**를 고려할 차례임.
38. `interrupt`는 영어로 방해, 중단을 의미함.
39. CPU가 잠시 작업을 중단해야 할 때 동작함.
40. 인터럽트는 동기 인터럽트와 비동기 인터럽트로 나뉨.
41. 동기 `sync` 인터럽트는 CPU가 예외적인 상황을 마주쳤을 때 발생시킴.
42. 비동기 `async` 인터럽트는 보통 입출력장치에 의해 발생함. `하드웨어 인터럽트`라고도 부름.

### 하드웨어 인터럽트

43. 하드웨어 인터럽트는 알림과 같음. 입출력 작업 중에도 효율적으로 명령을 처리하기 위한 것.
44. 하드웨어 인터럽트를 확인하면 CPU는 주기적으로 프린트 완료 여부를 확인할 필요가 없음.
45. 1번: IO decive가 인터럽트 요청 신호를 보냄
46. 2번: CPU는 실행 사이클 끝나고 명령어 인출 전 `인터럽트 여부를 확인`함.
47. 3번: CPU는 인터럽트 플래그`(flag register에 있음)` 를 통해 인터럽트를 `받아들일 수 있는지 여부를 확인`함.
48. 4번: 받아들일 수 있다면 지금까지의 작업을 백업함.
49. 5번: 인터럽트 벡터를 참고해 `인터럽트 서비스 루틴`을 실행함
50. 6번: 서비스루틴 실행이 끝나면 백업해둔 작업을 복구해 실행을 재개.
51. 이제 인터럽트 플래그 이야기를 해야 하는데, `flag register`에서 1bit를 차지하는 녀석임.
52. 인터럽트 플래그로 막을 수 있는 인터럽트와(`maskable interrupt`) 하드웨어 고장, 정전 등 막을수 없는 인터럽트가(`non maskable interrupt`) 있음.
53. 인터럽트 서비스 루틴 이야기를 해야 함. 인터럽트 핸들러 `interrupt handler`라고도 부름
54. 키보드가 인터럽트 요청을 보내면 → 이렇게 작동한다 등의 작동 방법에 대한 정보로 이루어진 프로그램임.
55. 인터럽트 백터 `interrupt vector` → 인터럽트 서비스 루틴의을 식별하기 위한 정보
56. 다시 말해, 인터럽트를 처리한다 = `인터럽트 서비스 루틴을 실행하고 본래 수행하던 작업으로 돌아온다` 임.
57. 처리하던 정보들은 그냥 덮어씌우면 안됨.
58. 이 정보들은 스택에 올려놓았다가 인터럽트 서비스 루틴이 끝나면 다시 불러와서 재개해야 함.
![Untitled 4](https://github.com/Ssafy-Developer-Study/CS-study/assets/39848764/1b43722c-8dae-4658-821b-a711d19604f7)
