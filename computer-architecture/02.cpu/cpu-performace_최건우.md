# 🅒🅟🅤 성능 향상 기법

# 빠른 CPU를 위한 설계기법

1. 클럭, 멀티코어, 멀티스레드에 대해 알아보자.
2. 컴퓨터 부품들은 클럭 신호에 맞춰서 움직임.
3. CPU는 명령어 사이클이라는 흐름에 맞춰 명령어를 실행함.
4. 클럭신호가 빠르게 반복되면? 부품이 더 빨리 움직이고 명령 실행도 빨라질 것임.
5. 그래서 클럭 속도가 높으면 일반적으로 성능이 좋은 것임.
6. 클럭은 Hz 단위로 부름. 일반적으로느 GHz를 많이 씀.
7. 그리고 클럭 속도는 발열 등에 따라 유동적임. 발열이 커지기 때문에 클럭을 밑도끝도없이 늘릴수는 없음.
8. 그러면 다른 방식으로 성능을 높일 방법을 생각해야함. 바로 CPU 코어와 스레드를 늘리는 것.
9. 오늘날의 명령어를 실행하는 CPU라는 부품은, 이제 ‘코어’ 단위가 되었음.
10. 즉, CPU란 `명령어를 실행하는 부품을 모아놓은 부품` 인것.
11. 이제 이 녀석을 멀티코어 프로세서라고 부름.
12. 스레드 이야기로 넘어가보겠음.
13. 스레드는 `하드웨어적 스레드`와 `소프트웨어적스레드`가 서로 의미가 다름.
14. `하드웨어적 스레드`란, ‘하나의 코어가 동시에 처리하는 명령어 단위`임.
15. 지금까지 배운 CPU는 한번에 하나씩의 명령어를 실행함.
16. 하지만 멀티스레드 CPU는 코어 하나가 여러개의 명령어(스레드)를 동시에 실행함.
17. 그래서 8코어 16스레드같은 말이 있는 것.
18. `소프트웨어적 스레드`는 ‘하나의 프로그램에서 독립적으로 실행되는 단위’임.
19. 프로그램에 여러 스레드를 올리면, 동시에 연산을 실행함.

![Untitled 1](https://github.com/Ssafy-Developer-Study/CS-study/assets/39848764/4cc8cdc9-08b4-4ac7-a2b8-171c34153a7b)

20. 멀티스레드 프로세서에 대해 이야기해보겠음.
21. 멀티스레드 프로세서를 만드는 데에 가장 핵심적인 과제는 레지스터임.
22. 가령 프로그램 카운터가 두개가 되면, 한번에 두개의 명령을 실행할 수 있게 되는것임.

![Untitled 2](https://github.com/Ssafy-Developer-Study/CS-study/assets/39848764/826aabfa-5764-4156-881b-b416e49a6406)

23. 그래서 이렇게 스레드가 2코어 4스레드 CPU는, `논리 프로세서가 4개다` 라고도 할 수 있음.

# 명령어 병렬 처리 기법

24. 물론 빠른 클럭, 멀티코어 멀티스레드도 중요하지만 CPU가 놀지 않고 시간을 알뜰하게 쓰며 작동하게 하는 것도 중요함.
25. 명령어 병렬처리기법인 `명령어 파이프라이닝`, `슈퍼스칼라`, `비순차적 명령어 처리`에 대해 알아볼 것임.
26. 명령어 파이프라인은 `인출fetch`, `해석decode`, `실행execute`, `저장write back` 순으로 이뤄짐.
27. 중요한 점은 각 단계가 겹치지만 않으면 동시에 실행할 수 있다는 것.

![Untitled 3](https://github.com/Ssafy-Developer-Study/CS-study/assets/39848764/0164de01-c6e6-453b-bdb9-3499ee75de3c)

28. 명령어 파이프라인에 명령어들을 넣고, 동시에 처리하는 기법을 명령어 파이프라이닝이라고 함.
29. 다만 여기에는 예상치 못한 버그가 생길수도 있는 위험 `harzard`가 도사리고 있음.
30. 데이터 위험,제어위험, 구조적 위험이 그것임.
31. `데이터 위험`은 파이프라이닝을 하는 동안 같은 데이터에 접근하느라 옳지 않은 값을 받을 것에 대한 위험임. 
32. 가령, `R1 <- R2 + R3; R4 <- R1 + R5` 를 연속으로 파이프라이닝하면 발생할 위험이 있음.
33. `제어위험`은 프로그램 카운터의 분기 변화에 의해 발생함.
34. 예상치 못한 프로그램의 변화에 의해 기존에 처리하던 내용이 헛수고가 되는 것임.
35. 이를 해결하기 위해 `branch prediction`이 있는 것임. 이를 통해 알고리즘 성능을 개선할 여지가 있음.
36. `구조적 위험`은 서로 다른 명령어가 ALU, 레지스터 등에 동시 접근하려고 할 위험에 대한 문제임. “자원위험”이라고도 부름.
37. `슈퍼스칼라` 는 그냥 여러개의 파이프라인을 쓰는 것임.
38. 다만 파이프라인 위험등의 문제가 있어 비례해서 빨리지지는 않음.
39. `비순차적 명령어 처리`가 병렬 처리에 크게 기여함.
40. 먼저 실행해도 상관 없는 명령어를 순서를 바꿔서 파이프라이닝 하는 것.

# CISC & RISC

41. ISA에 대해 우선 알아야 함.
42. ISA는 명령어 집합 구조 `instruction set architecture`임.  CPU마다 명령어 집합이 다 다름.
43. ISA가 다르면, CPU의 행동 양식도 달라질 수밖에 없음.
44. `CISC`에 대해서 알아보겠음.
45. `Complex Instruction Set Computer`임. “복잡한 명령어 집합”이 핵심임.
46. 다양하고 강력한 명령어를 사용하기 때문에, 적은 수의 명령어로 프로그램을 실행함.
47. 대신 명령어마다 길이가 다르고, 소요 클럭이 다양하기 때문에 효율적인 착착착 파이프라이닝에 어려움이 있음.
    
![Untitled 4](https://github.com/Ssafy-Developer-Study/CS-study/assets/39848764/fa050278-32f9-4df9-9808-27b433291920)

48. `RISC` 는 `Reduced Instruction Set Computer`임.
49. 짧고 규격화된 명령어가 1클럭 내에 실행되는 것을 지향함.
50. 그렇기 때문에 명령어 파이프라이닝에 최적화되어있음. 메모리에 직접 접근하는 명령어가 load-store 두개밖에 없고, 주소 지정 방식의 종류도 더 적음.
51. RISC는 메모리 접근을 단순화, 최소화하는 대신 레지스터를 적극적으로 활용함.
52. 다만 더 많은 명령으로 프로그램을 작동시킴.
