### 빠른 CPU를 위한 설계 기법

- **클럭 속도**
    - 헤르츠(Hz) 단위로 측정
        - 1초에 클럭이 반복되는 횟수
    - 클럭이 1초에 한 번 반복되면 1Hz, 100번 반복되면 100Hz
- 컴퓨터 부품들은 '클럭 신호'에 맞춰 일사불란하게 움직임
- CPU는 '명령어 사이클'이라는 정해진 흐름에 맞춰 명령어들을 실행
    - 클럭 신호가 빠르게 반복되면 CPU의 속도가 빨라질까?
    - 꼭 그런 건 아니지만 일반적으로 YES
    - BUT 클럭 속도를 필요 이상으로 높이면 발열이 심각해짐
- **코어(Core)**
    - 전통적으로 CPU = 명령어를 실행하는 부품 (원칙적으로 1개만 존재)
    - 하지만 오늘날에는 CPU에 명령어를 실행하는 부품이 여러 개 존재
        - Core = 명령어를 실행하는 부품
- **멀티 코어**
    - e.g. 듀얼코어(2), 트리플코어(3), 쿼드코어(4), 헥사코어(6), ...
- 코어 수를 늘려 CPU의 속도 향상을 꾀할 수 있음
    - BUT 코어 수에 비례하여 증가하지는 않음
        - e.g. 코어마다 처리해야 할 연산이 적절하게 분배되지 않을 경우

### 스레드

- **하드웨어적 스레드**
    - 하나의 코어가 동시에 처리하는 명령어 단위
    - 논리 프로세서라고도 부름
    - e.g. CPU에 코어가 2개 있고, 각 코어가 2개의 명령어를 동시에 실행할 수 있다면 2코어 4스레드 CPU
    - 하나의 코어가 여러 개의 명령어를 동시에 처리할 수 있는 CPU = 멀티 스레드 프로세서, 멀티 스레드 CPU
- **소프트웨어적 스레드**
    - 하나의 프로그램에서 독립적으로 실행되는 단위
    - e.g. 입력받은 내용을 화면에 보여주는 기능 + 맞춤법 검사 기능 + 수시로 저장하는 기능 = 3개의 흐름을 동시에 실행 (멀티스레드)
    - 1코어 1스레드 CPU(하드웨어적 스레드=1개)도 여러 소프트웨어적 스레드를 만들 수 있음 (빠르게 번갈아가면서 실행함으로써 여러 개가 동시에 실행되는 것처럼 느껴지게끔)

## **명령어 병렬 처리 기법**

### 명령어 파이프라인

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e11f4eac-f83e-4911-a354-01d8604e4e59/b4a4839b-7367-4c65-8752-d9d377720688/Untitled.png)

- 같은 단계가 겹치지만 않는다면 CPU는 '각 단계를 동시에 실행할 수 있다
- 명령어 파이프라이닝은 동시에 여러 개의 명령어를 겹쳐 실행하는 기법
    1. 명령어 인출 (Instruction Fetch)
    2. 명령어 해석 (Instruction Decode)
    3. 명령어 실행 (Execute Instruction)
    4. 결과 저장 (Write Back)

### 슈퍼 스칼라

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e11f4eac-f83e-4911-a354-01d8604e4e59/0f69f5da-ef9e-46dd-aae3-c53bf446383d/Untitled.png)

- CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조
- 오늘날의 멀티스레드 프로세서 (하드웨어적 스레드)
- 이론적으로는 파이프라인 개수에 비례하여 처리 속도 증가
    - BUT 파이프라인 위험도의 증가로 인해 개수에 비례하여 처리 속도가 증가하진 않음

### 비순차적 명령어 처리

- 파이프라인의 중단을 방지하기 위해 명령어를 순차적으로 처리하지 않는 명령어 병렬 처리 기법
    - 합법적인 새치기

• 명령어를 순서대로 실행할 때 파이프라이닝을 활용할 수 없음 (3번 과정 때문에)

- 의존성이 없는 명령어의 순서를 바꿔서 파이프라이닝을 최대로 활용할 수 있음
    - 아무 명령어나 순서를 바꿀 수는 없음 (의존성 고려 필요)
    - 전체 프로그램 실행 흐름에 영향이 없는 경우에만 가능

## **명령어 집합 구조, CISC과 RISC**

### 명령어 집합 구조란?

- CPU가 이해할 수 있는 명령어들의 모음
- **CPU의 언어**이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속
    - 명령어가 달라지면 명령어 해석 방식, 레지스터의 종류와 개수, 파이프라이닝의 용이성 등이 달라짐

### CISC

- 복잡한 명령어 집합을 활용하는 컴퓨터(CPU)
    - e.g. x86, x86-64
- 명령어의 형태와 크기가 다양한 가변 길이 명령어 활용
- 강력한 명령어를 활용
    - 상대적으로 적은 수의 명령어로도 프로그램 실행 가능
- 메모리를 최대한 아끼며 개발해야 했던 시기에는 인기가 높았음
- 하지만 **명령어 파이프라이닝이 불리**
    - 명령어의 크기와 실행되기까지의 시간이 일정하지 않음
    - 명령어 하나를 실행하는 데에 여러 클럭 주기 필요
- 대다수의 복잡한 명령어는 사용 빈도가 낮음

### RISC

- 명령어의 종류가 적고, 짧고 규격화된 명령어 사용e.g. ARM
- 단순하고 적은 수의 고정 길이 명령어 집합을 활용
    - **명령어 파이프라이닝에 유리**
- 메모리 접근 최소화(load, store), 레지스터 십분 활용
- 명령어 종류가 CISC보다 적기에 더 많은 명령어로 프로그램을 동작시킴

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e11f4eac-f83e-4911-a354-01d8604e4e59/b141c35c-ad37-4082-8ff1-c4add12c0188/Untitled.png)