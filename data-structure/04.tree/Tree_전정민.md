# 트리

## 1. 개요 

* 한 노드가 여러 노드를 가리킬 수 있는 비선형적 자료구조
* 그래프의 일종이다.
![jvm](../img/%ED%8A%B8%EB%A6%AC.png)
* 용어
    * Node: 트리 구조에서 각 구성요소(A ~ J)
    * Root Node: 부모가 없는 최상위 노드(A 노드)
    * Edge: 간선
    * Path: 특정 노드에서 노드까지의 경로
    * Leaf Node: 자식 노드가 존재하지 않는 노드
    * Sub tree: 전체 큰 트리 구조 안의 작은 트리 구조
    * Depth: 루트 노드로부터 얼마나 떨어져 있는 지를 뜻하는 단위
    * Level: 같은 depth를 가지는 노드들은 한 레벨로 나타낸다.
    * Height: 트리에서 가장 최고 레벨
* 종류
    * 이진트리
    * 삼항트리
    * 이진탐색트리(BST)
    * 힙

## 2. 이진트리

* 각 노드의 자식 수가 최대 2개인 트리
* n개의 노드를 가진 이진트리는 n-1개의 간선을 갖는다.

### 이진트리 유형
* 정 이진트리(Full Binary Tree): 모든 노드가 2개의 자식을 가지거나 자식이 없는 경우
* 포화 이진트리(Perfect Binary Tree): 모든 노드가 2개의 자식을 가지고 leaf 노드가 모두 같은 레벨인 경우
* 완전 이진트리(Complete binary tree): 마지막 레벨을 제외한 각 레벨이 노드들로 꽉 차있고(마지막 레벨의 노드는 다 채워져 있을 수도 있고 아닐 수도 있다), 마지막 레벨에는 노드들이 왼쪽부터 채워진 형태
* 포화 이진트리는 완전이진트리이다. 하지만 역은 성립하지 않는다.
* 균형 이진트리(Balanced Binary Tree): 모든 노드의 좌우 서브 트리 높이가 최대 1만큼 차이가 날 수 있는 이진트리이다.

### 이진트리의 표현

1. 순차 자료구조 방식

![jvm](../img/%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC.png)

* 인덱스 1번에 루트를 저장
* 각 노드의 부모 노드와 자식 노드가 저장된 배열 인덱스에 대하여 일정한 규칙을 찾을 수 있다.

|노드|인덱스|조건|
|------|---|---|
|노드 i의 부모 노드|i / 2|i > 1|
|노드 i의 왼쪽 자식 노드|i * 2|(i * 2) <= n|
|노드 i의 오른쪽 자식 노드|(i * 2) + 1|(i * 2) + 1 <= n|

2. 연결 자료구조 방식

* 배열을 통한 구현은 편향 이진 트리의 경우 공간 낭비를 많이 할 수 있다.

``` java

public class TreeNode {
    private Object data;
    TreeNode left;
    TreeNode right;

    public TreeNode(Object data) {
        this.data = data;
        this.left = null;
        this.right = null;
    }

    public Object getData() {
        return this.data;
    }
}

```

## 3. 이진 탐색 트리

### 개념

* 이진 탐색과 연결리스트를 결합한 자료구조의 일종이다.
    * 이진 탐색의 효율적인 탐색 능력을 유지하면서, 빈번한 자료 입력과 삭제를 가능하게 한다.
* 이진 트리의 일종으로 다음의 규칙을 가지고 있다.
    * 중복되는 노드가 없어야 한다.
    * 각 노드의 왼쪽 서브트리에는 해당 노드의 값보다 작은 값을 지닌 노드들로 이루어져 있다.
    * 각 노드의 오른쪽 서브트리에는 해당 노드의 값보다 큰 값을 지닌 노드들로 이루어져 있다.
    * 왼쪽, 오른쪽 서브트리 또한 이진탐색 트리이다.

### 특징

* 트리의 높이를 h라고 할 때, 탐색의 시간 복잡도는 O(h)이다.
* 이진탐색 트리의 순회는 중위 순회 방식이다.
* 삽입 연산은 루트노드에서 시작해 서브트리가 없는 리프 노드에서 이루어진다.
* 삭제는 세가지 케이스로 나누어진다.
    1. 자식 노드가 없는 경우: 삭제할 노드를 그냥 없앤다.
    2. 자식 노드가 하나 있는 경우: 삭제할 노드의 자식을 올린다.
    3. 자식 노드가 두 개 있는 경우: 오른쪽 서브트리에서 가장 작은 값 or 왼쪽 서브트리에서 가장 큰 값을 올린다.(서로 차이 없음)
    

## 4. 힙(heap)

### 개념

* 여러 개의 값 중에서 가장 크거나 가장 작은 값을 빠르게 찾기 위해 만든 이진 트리이다.
* 항상 완전 이진트리의 형태를 띄어야 한다.
* 최대 힙: 부모의 값은 항상 자식의 값보다 커야한다.
* 최소 힙: 부모의 값은 항상 자식의 값보다 작아야한다.
* 따라서 루트 노드에는 항상 데이터들 중 가장 큰 값(작은 값)이 저장되어 있기 때문에, 최대값(최소값)을 O(1)안에 찾을 수 있다.

### 데이터 처리

* 완전 이진트리이므로 레벨이 늘어날 수록 노드 수가 두배씩 증가한다.
* 따라서 레벨이 i일 때 노드의 개수는 2^(i-1)개이다.
* 따라서 높이는 logi + 1이다.
* 따라서 삽입과 삭제는 O(logN)이다.

### 데이터의 삽입

1. 가장 끝의 자리에 노드를 삽입한다.
2. 그 노드와 부모 노드를 서로 비교한다.
3. 규칙에 맞으면 그대로 두고, 그렇지 않으면 부모와 교환한다.
4. 규칙에 맞을 때까지 3번의 과정을 반복한다.

### 데이터의 삭제

1. 최대값 혹은 최소값이 저장된 루트 노드만 제거할 수 있다.
2. 루트 자리에 가장 마지막 노드를 삽입한다. (수정될 힙에서 중간에 빈공간이 생기지 않게 하기 위함)
3. 올라간 노드와 그 자식 노드를 비교한다.
4. 조건에 만족하면 그대로 두고, 그렇지 않으면 자식과 교환한다.

* 최대힙
    1. 부모보다 더 큰 자식이 없으면 교환하지 않고 끝낸다.
    2. 부모보다 더 큰 자식이 하나만 있으면 그 자식하고 교환하면 된다.
    3. 부모보다 더 큰 자식이 둘 있으면 자식들 중 큰 값과 교환한다.
* 최소힙
    1. 부모보다 더 작은 자식이 없으면 교환하지 않고 끝낸다.
    2. 부모보다 더 작은 자식이 하나만 있으면 그 자식하고 교환하면 된다.
    3. 부모보다 더 작은 자식이 둘 있으면 자식들 중 작은 값과 교환한다.
5. 조건을 만족할 때까지 4의 과정을 반복한다.