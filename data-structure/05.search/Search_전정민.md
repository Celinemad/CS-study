# 탐색

## 1. 탐색 알고리즘

### 개요

여러 개의 자료 중 원하는 자료를 찾는 작업을 탐색이라고 한다. 탐색 알고리즘의 기초 단위는 "항목"이다. 이 항목은 간단한 숫자일 수도, 구조체가 될 수도 있다.
항목 안에는 항목과 항목을 구별하는 key가 존재한다. 이것을 탐색 키라고 한다.
> 탐색은 탐색 키와 데이터로 이루어진 여러 항목 중에서 원하는 탐색 키를 가진 항목을 찾는 것이다.

### 종류

* 탐색 알고리즘은 정렬되지 않은 리스트에서 탐색하는 방법과 정렬된 리스트에서 탐색하는 방법으로 나뉜다.
* 정렬되지 않은 리스트에서 탐색하는 방법으로는 순차 탐색이 있다.
* 정렬된 리스트에서 탐색하는 방법으로는 이진 탐색, 색인 순차 탐색, 보간 탐색이 있다.

## 2. 순차 탐색

### 방법

* 처음부터 마지막까지 하나씩 순차대로 검사하여 항목을 탐색하는 방법
* 선형 탐색: 단방향으로 진행하는 방법
* 배열을 선언한 후 앞에서부터 탐색값과 일치하는 항목을 찾을 때까지 하나하나 순차적으로 탐색한다. 탐색 값과 일치하는 값을 찾으면 그 항목의 인덱스를 반환하고, 탐색값과 일치하지 않는 경우 반복문을 빠져나와 -1을 반환한다.

### 구현

```java
static int sequentialSearch(int[] arr, int x) {
    int n = arr.length;
    int key = x;
    int[] arr2 = arr;
    int ret = -1;
    for(int i=0; i<n; i++) {
        if(arr2[i] == key) {
            ret = i;
            return ret;
        }
    }
    return ret;
}
```
* 시간 복잡도: O(n)

## 3. 이진 탐색

### 방법

* 어떤 배열에서 특정 값을 찾으려 할 때, 배열을 반으로 쪼개어 찾고자 하는 값이 왼쪽에 있는지 오른쪽에 있는지를 찾아 탐색 범위를 좁힌다.
* 비교가 이루어질 때마다 탐색 범위가 급속도로 줄어들어 매우 빠른 탐색을 진행할 수 있다.
* 반드시 배열이 정렬되어 있어야 한다. 따라서 추가되거나 삭제되지 않는 고정 데이터에서 유용하다.

### 구현

```java
static int[] arr;

static int binarySearch1(int key, int lo, int hi) {
    int mid;
    if(lo <= hi) {
        mid = (lo + hi) / 2;

        if(key == arr[mid]) {
            return mid; 
        } else if(key < arr[mid]) {
            return binarySearch1(key, lo, mid-1);
        } else if(key > arr[mid]) {
            return binarySearch1(key, mid+1, hi);
        }
    }
    return -1;
}

static int binarySearch2(int key, int lo, int hi) {
    int mid;
    while(lo <= hi) {
        mid = (lo + hi) / 2;

        if(key == arr[mid]) {
            return mid;
        } else if(key < arr[mid]) {
            hi = mid - 1;
        } else if(key > arr[mid]) {
            lo = mid + 1;
        }
    }
    return -1;
}
```

* 시간 복잡도: O(log n)
* 자바에서 Arrays.binarySearch(arr, value) 존재

## 4. 이진 탐색 트리(BST)

### 방법

* 이진 탐색과 연결리스트를 결합한 자료구조의 일종이다.
    * 이진 탐색의 효율적인 탐색 능력을 유지하면서, 빈번한 자료 입력과 삭제를 가능하게 한다.
* 이진 트리의 일종으로 다음의 규칙을 가지고 있다.
    * 중복되는 노드가 없어야 한다.
    * 각 노드의 왼쪽 서브트리에는 해당 노드의 값보다 작은 값을 지닌 노드들로 이루어져 있다.
    * 각 노드의 오른쪽 서브트리에는 해당 노드의 값보다 큰 값을 지닌 노드들로 이루어져 있다.
    * 왼쪽, 오른쪽 서브트리 또한 이진탐색 트리이다.

### 특징

* 트리의 높이를 h라고 할 때, 탐색의 시간 복잡도는 O(h)이다.
* 이진탐색 트리의 순회는 중위 순회 방식이다.
* 삽입 연산은 루트노드에서 시작해 서브트리가 없는 리프 노드에서 이루어진다.
* 삭제는 세가지 케이스로 나누어진다.
    1. 자식 노드가 없는 경우: 삭제할 노드를 그냥 없앤다.
    2. 자식 노드가 하나 있는 경우: 삭제할 노드의 자식을 올린다.
    3. 자식 노드가 두 개 있는 경우: 오른쪽 서브트리에서 가장 작은 값 or 왼쪽 서브트리에서 가장 큰 값을 올린다.(서로 차이 없음)
    