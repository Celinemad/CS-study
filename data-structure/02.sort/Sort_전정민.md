# 정렬


힙정렬/병합정렬/퀵정렬

## 1. 버블 정렬

### 이해와 구현

* 비교 정렬: 두 개의 인접한 원소를 비교하며 정렬하는 방식이다.
* 정렬 과정에서 원소의 이동이 거품같다고 해서 버블 정렬이라는..
* 제자리 정렬: 정렬의 대상이 되는 데이터 외에 추가적인 공간을 필요로 하지 않는다.

* 전체적인 과정
     1. 앞에서부터 현재 원소와 바로 다음의 원소를 비교한다.
     2. 현재 원소가 다음 원소보다 크면 원소를 교환한다.
     3. 다음 원소로 이동하여 해당 원소와 그 다음 원소를 비교한다.

* [구현1](./BubbleSort.java), [구현2](./BubbleSort.java)
* 구현2의 경우 한 라운드에서 swap이 일어나지 않으면 이미 정렬 됐다고 판단하여 반복문을 종료한다.

### 성능 평가

* 다른 알고리즘에 비해 교환 과정이 많아 시간을 소비한다.
* 시간 복잡도: O(n^2)
> 하지만 구현2처럼 구현한다면 O(n)까지도 줄일 수 있는 여지가 있다.

## 2. 선택 정렬

### 이해와 구현

* 현재의 위치에 들어갈 데이터를 찾아 선택하는 알고리즘
* 비교 정렬, 제자리 정렬
* 전체적인 과정
    1. 주어진 리스트에서 최솟값을 찾는다.
    2. 최솟값을 맨 앞자리의 값과 교환한다.
    3. 맨 앞 자리를 제외한 나머지 값들 중 최소값을 찾아 위와 같은 방법으로 반복한다.
* [구현](./SelectionSort.java)

### 성능 평가

* 시간 복잡도: O(n^2)

## 3. 삽입 정렬

### 이해와 구현

* 타겟과 그 이전의 원소들을 비교하여 자리를 교환하는 정렬
* 비교 정렬, 제자리 정렬
* 전체적인 과정
    1. 현재 타켓이 되는 숫자와 이전 위치에 있는 원소들을 비교한다.
    2. 타겟이 되는 숫자가 이전 위치에 있던 원소보다 작다면 위치를 서로 교환한다.
    3. 그 다음 타겟을 찾아 위와 같은 방법으로 반복한다.
> 두번째 원소부터 시작
* [구현](./InsertionSort.java): 결과적으로 타겟 이전 원소가 타겟 숫자보다 작을 때까지 모든 수를 뒤로 한 칸씩 밀어내는 것이다.

### 성능 평가

* 거의 정렬된 경우 매우 효율적이다. 최선의 경우 O(n)의 복잡도를 갖는다.
* 데이터의 상태에 따라서 성능 편차가 매우 크다. 최악의 경우 O(n^2)이다.

## 4. 힙 정렬

## 5. 병합 정렬

### 이해와 구현

* 분할 정복 알고리즘을 기반으로 정렬되는 방식
* 비교정렬이며 제자리 정렬이 아니다!
* 전체적인 과정
    * 주어진 리스트를 절반으로 분할하여 부분리스트로 나눈다.
    * 해당 부분리스트의 길이가 1이 아니라면 1번 과정을 반복한다.
    * 인접한 부분리스트끼리 정렬하여 합친다.
* [구현](./MergeSort.java)

### 성능 평가

* 최악의 경우에도 시간복잡도 O(nlogn) 유지
* 메모리 사용량이 많다.
* 보조 배열에서 원본 배열로 복사하는 과정에서 많은 시간을 소비한다.

## 6. 퀵 정렬

### 이해와 구현

* 분할 정복 알고리즘을 기반으로 정렬되는 방식이다.
* 비교 정렬, 제자리 정렬
* 합병 정렬과 달리 리스트를 비균등하게 분할한다.
* 전체적인 과정
    1. 리스트 안에 있는 한 요소를 선택한다. 이것을 피벗이라고 부른다.
    2. 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다.   
    3. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.(분할된 부분 리스트에 대해서 재귀 호출을 이용하여 정렬을 반복한다.)
    4. 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.
* 피벗을 선택하는 방식이 여러 개가 있다.
* [왼쪽 피벗](./LeftQuickSort.java), [오른쪽 피벗](./RightQuickSort.java), [가운데 피벗](./MidQuickSort.java)

### 성능 평가

* 시간 복잡도: O(nlogn)
* 정렬된 상태의 배열을 정렬할 때 최악의 성능을 낸다. -> O(n^2)


## 7. 자바에서의 정렬

### Arrays.sort() -> Dual pivot quicksort

* 일반적인 퀵 정렬과 달리 두 개의 피벗을 사용하여 정렬하는 방식이다.
* 더 많은 분할로 인해 비교 및 교환 횟수가 줄어들기 때문에 속도가 더 빠르다.
* 하지만 구현이 복잡하며, 최악의 경우 여전히 O(n^2)이다.
![img](../img/dualpivot.png)
* [구현](./DualPivotQuickSort.java)