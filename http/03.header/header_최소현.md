## HTTP 구조

- 전체 구성 : HTTP는 Head와 Body로 구성
- 한 세트 구성 : 문자열 (대소문자 구분없음) / 콜론(’:’) / 값


### 요청 메시지

- head
    - start-line과 **header** 로 구성
    - start-line
        - HTTP 메서드 (GET, PUT, POST)
        - 요청 타겟 (URL)
        - HTTP 버전 (HTTP/1.1)
    - header
        
        아래 설명 예정
        
- body (본문)
    - 모든 요청에 본문이 있지 않음 (보통 post일때 사용)
    - single-resource body
    - multiple-resource body

### 응답 메시지

- head 
    - start-line
        - HTTP 버전 (HTTP/1.1)
        - 상태 코드

- body (본문)
    - 모든 요청에 본문이 있지 않음 (보통 post일때 사용)
    - single-resource body
    - multiple-resource body

## 구성요소

### 요청 헤더

| Header              | Description         |
|---------------------|---------------------|
| Accept              | 클라이언트가 허용할 수 있는 파일 형식(MIME TYPE). `*/*`은 모든 파일형식 지원 |
| User-Agent          | 클라이언트 소프트웨어(os, 브라우저 등)의 이름과 버전   |
| Host                | 요청을 한 서버의 Host                                 |
| If-Modified-Since   | 페이지가 수정되었으며 최신 페이지 요청을 위한 필드    |
| Referer             | 링크를 제공한 페이지 (이전 페이지)                    |
| Cookie              | 쿠키를 저장해 놓았다면 해당 쿠키의 정보를 이름-쌍으로 웹서버에 전송 |
| Accept-Language     | 클라이언트가 인식할 수 있는 언어로, 우선 순위 지정이 가능 |
| Accept-Encoding     | 클라이언트가 인식할 수 있는 인코딩 (gzip, deflate)    |


### 응답 헤더
| Header              | Description         |
|---------------------|---------------------|
| Server | * 웹서버 정보를 나타냄 |
| --- | --- |
| Date | * 현재 날짜 |
| Content-Type | * 요청한 파일의 MINE 타입 |
| Last-Modified | * 요청한 파일의 최종 수정일 |
| Content-Length | * 헤더 이후 이어지는 데이터의 길이 (바이트 단위) |
| ETag | * 캐쉬 업데이트 정보를 위한 임의의 식별 숫자 |
|  |  |

### 중요한 놈들

- Host
    
    ip로만 통신하기 때문에, 정확히 어떤 경로로 접속해야하는지 알려줘야함
    
- Location (페이지 리다이렉션)
    
    웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, 자동 이동
    
- Allow
    
    허용가능한 HTTP 메서드
    
- Retry-After
    
    유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간
    
- Autherization
    
    클라이언트 인증 정보를 서버에 전달
    

## 쿠키

### 구성요소
- Set-Cookie
    
    서버에서 클라이언트로 쿠키 전달
- Cookie
    
    클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달

### 동작과정
1. 클라이언트가 페이지를 요청 (웹 서버는 쿠키를 생성)
2. 생성한 쿠키에 정보를 담아 클라이언트에게 HTTP 응답시 같이 돌려줌
3. 넘겨받은 쿠키는 클라이언트가 가지고 있다가(브라우저에 저장) 다시 서버에 요청할 때 요청과 함께 쿠키를 전송

### 특징
- 유지 기간: 쿠키는 만료 날짜 또는 세션 종료 시까지 유지됨
- 도메인 및 경로 제한: 쿠키는 특정 도메인 및 경로에 대해 설정되며, 이 범위를 벗어난 요청에는 포함되지 않음.
- 보안: `Secure` 플래그가 설정된 쿠키는 HTTPS 프로토콜을 통해서만 전송. `HttpOnly` 플래그가 설정되면 자바스크립트 등의 스크립트를 통한 접근이 제한.

## 캐시

### 동작 과정
1. 클라이언트가 웹페이지 또는 리소스를 요청
2. 캐시에 해당 리소스가 있는지 확인하고, 유효한 경우 캐시에서 리소스를 제공
3. 캐시된 복사본이 없거나 만료된 경우, 서버에 직접 요청하여 리소스를 가져옴
4. 서버로부터 받은 리소스를 클라이언트에게 전달하면서 캐시에 저장

### 특징
- 성능 개선: 자주 사용되는 리소스를 캐시에 저장함으로써, 서버 요청 횟수를 줄이고 로딩 시간을 단축
- 유효 기간: 캐시된 리소스는 `Cache-Control` 헤더에 정의된 만큼의 시간 동안만 유효
- 캐시 유효성 검증: `ETag` 및 `Last-Modified` 헤더를 사용하여 캐시된 리소스의 유효성을 검증하고, 필요한 경우 새로운 리소스를 다운로드

## 검증헤더와 조건부 요청

### 검증 헤더

- 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
- `Last-Modified`
- `ETag` : 캐시용 데이터에 고유한 버전 이름을 부여 (같으면 유지, 다르면 다시 받기)

### 조건부 요청 헤더

- 검증 헤더로 조건에 따른 분기
- `If-Modifed-Since` : Last-Modified와 함께 사용
- `If-None-Match` : ETag와 함께 사용
- 조건 만족시 200, 조건 만족하지 않을시 304 (Not Modified)

### 캐시 지시어

- `max-age` :  캐시 유효 시간 (초단위)
- `no-cache` : 데이터는 캐시해도 되지만 항상 원서버에 검증하고 사용
- `no-store` : 데이터에 민감한 정보가 있으므로 저장하면 안됨

## 프록시 캐시

### 프록시란?

- 정의
    - 사전적 의미 : 대리
    - 클라이언트-서버 간의 중계 역할을 하는 녀석
- 프록시 위치에 따른 구분
    - 포워드 프록시
        클라이언트 앞에 놓여져 있으며, client의 ip가 변경되는 것
        
    - 리버스 프록시
        WAS / 웹서버 앞에 놓여져 있으며, server의 ip가 변경되는 것
        
        - 예) 로드 밸런싱
- 사용 프로토콜에 따른 구분
    - HTTP 프록시
        - 웹 트래픽을 중재
        - 프록시 자체적으로 HTTP 프로토콜을 읽을 수 있으며, 캐싱-요청 필터링-인증 등 많은 기능을 제공
    - SOCKS 프록시
        - 어떠한 프로토콜도 중재 (FTP, SMTP, 등)
        - 프로토콜의 세부사항을 이해하지 못함. 단순히 전달만 함
    

## HTTP 프록시 캐시

### 관련 지시어

- `Cache-Control`
    - public : 응답이 public 캐시 (프록시 캐시)에 저장되어도 됨
    - private : 응답은 사용자만을 위한 것으로, private 캐시 (클라이언트의 브라우저) 에만 저장해야함
- `age`
    - 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간